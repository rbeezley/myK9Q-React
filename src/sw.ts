/// <reference lib="webworker" />
// Service Worker Version: 2.4 - Green icon with solid background
import { clientsClaim } from 'workbox-core';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import { logger } from '@/utils/logger';

declare const self: ServiceWorkerGlobalScope;

// Define NotificationAction type (from Notifications API)
interface NotificationAction {
  action: string;
  title: string;
  icon?: string;
}

// Take control of all pages immediately
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Network-first strategy for Supabase API calls
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
  })
);

// =============================================
// PUSH NOTIFICATION HANDLING
// =============================================

interface PushPayload {
  type: 'announcement' | 'up_soon' | 'result' | 'class_started';
  title: string;
  body: string;
  license_key: string;
  priority?: 'normal' | 'high' | 'urgent'; // For announcements
  armband_number?: number;
  dog_name?: string;
  handler?: string;
  class_id?: string;
  entry_id?: string;
  url?: string;
  class_name?: string; // For class_started notifications
  class_status?: string; // For class_started notifications
  message_id?: string; // Optional unique message ID for duplicate detection
}

// =============================================
// DUPLICATE DETECTION
// =============================================

// In-memory cache for recent message IDs (lasts for service worker lifetime)
const recentMessageIds = new Set<string>();
const MESSAGE_ID_EXPIRY_MS = 15 * 60 * 1000; // 15 minutes

/**
 * Generate a message ID from payload if not provided
 * Used to detect duplicate notifications
 */
function generateMessageId(payload: PushPayload): string {
  if (payload.message_id) {
    return payload.message_id;
  }

  // Generate deterministic ID based on payload contents
  const parts = [
    payload.type,
    payload.license_key,
    payload.armband_number?.toString() || '',
    payload.entry_id || '',
    payload.title,
  ];

  return parts.join('-');
}

/**
 * Check if a message ID was recently seen
 * Returns true if this is a duplicate
 */
function isDuplicateMessage(messageId: string): boolean {
  if (recentMessageIds.has(messageId)) {
return true;
  }

  // Add to cache
  recentMessageIds.add(messageId);

  // Remove from cache after expiry time
  setTimeout(() => {
    recentMessageIds.delete(messageId);
  }, MESSAGE_ID_EXPIRY_MS);

  return false;
}

/**
 * Handle incoming push notifications
 * Shows notification even when app is closed
 */
self.addEventListener('push', (event: PushEvent) => {
if (!event.data) {
    logger.warn('[Service Worker] Push event has no data');
    return;
  }

  try {
    const payload: PushPayload = event.data.json();
// Check for duplicate messages
    const messageId = generateMessageId(payload);
    if (isDuplicateMessage(messageId)) {
return;
    }

    // Build notification options
    // For announcements, use priority to determine requireInteraction
    const isUrgentAnnouncement = payload.type === 'announcement' && payload.priority === 'urgent';
    const isClassStarted = payload.type === 'class_started';

    const options: NotificationOptions & { actions?: NotificationAction[]; vibrate?: VibratePattern } = {
      body: payload.body,
      icon: '/myK9Q-teal-192.png',
      badge: '/myK9Q-teal-192.png',
      vibrate: isUrgentAnnouncement || isClassStarted ? [200, 100, 200] : [100], // More prominent vibration for urgent/class started
      data: {
        url: payload.url || '/',
        type: payload.type,
        license_key: payload.license_key,
        entry_id: payload.entry_id,
        armband_number: payload.armband_number,
        priority: payload.priority,
        class_id: payload.class_id,
        class_name: payload.class_name,
      },
      requireInteraction: payload.type === 'up_soon' || isUrgentAnnouncement || isClassStarted, // Up-soon, urgent announcements, and class started require interaction
      tag: payload.type === 'announcement' ? `announcement-${Date.now()}` :
           payload.type === 'class_started' ? `class-started-${payload.class_id}` :
           `up-soon-${payload.armband_number}`,
    };

    // Add action buttons based on notification type (no icons - they're too small)
    if (payload.type === 'up_soon') {
      options.actions = [
        { action: 'view', title: 'View Entry' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    } else if (payload.type === 'announcement') {
      options.actions = [
        { action: 'view', title: 'View' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    } else if (payload.type === 'class_started') {
      options.actions = [
        { action: 'view', title: 'View Class' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    }

    // Show notification with error handling
    const promiseChain = self.registration.showNotification(payload.title, options)
      .then(() => {})
      .catch((error) => {
        logger.error('[Service Worker] ‚ùå showNotification failed:', error);
      });

    event.waitUntil(promiseChain);
  } catch (error) {
    logger.error('[Service Worker] Error handling push event:', error);
  }
});

/**
 * Handle notification clicks
 * Opens app and navigates to relevant page
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
// Close the notification
  event.notification.close();

  // Don't navigate if user clicked "dismiss"
  if (event.action === 'dismiss') {
    return;
  }

  // Determine URL to open
  const data = event.notification.data;
  let urlToOpen = '/';

  if (data.url) {
    urlToOpen = data.url;
  } else if (data.type === 'up_soon' && data.entry_id) {
    // Navigate to entry list (could be enhanced to open scoresheet)
    urlToOpen = `/entries`;
  } else if (data.type === 'announcement') {
    // Navigate to announcements page
    urlToOpen = `/announcements`;
  }

  // Full URL with origin
  const fullUrl = new URL(urlToOpen, self.location.origin).href;

  // Open or focus the app
  const promiseChain = self.clients
    .matchAll({ type: 'window', includeUncontrolled: true })
    .then((windowClients: readonly WindowClient[]) => {
      // Check if there's already a window open
      for (let i = 0; i < windowClients.length; i++) {
        const client = windowClients[i];
        if (client.url === fullUrl && 'focus' in client) {
          return client.focus();
        }
      }

      // No matching window found, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(fullUrl);
      }
    });

  event.waitUntil(promiseChain);
});

/**
 * Handle notification close events (optional analytics/logging)
 */
self.addEventListener('notificationclose', (_event: NotificationEvent) => {
  // Could send analytics event here if needed
});

/**
 * Handle service worker activation
 */
self.addEventListener('activate', (event) => {
event.waitUntil(self.clients.claim());
});

/**
 * Handle service worker installation
 */
self.addEventListener('install', (_event) => {
// Skip waiting to activate immediately
  self.skipWaiting();
});

/**
 * Handle messages from the main thread
 * Used for simulating push notifications in development
 */
self.addEventListener('message', (event: ExtendableMessageEvent) => {
// Handle simulated push notifications (for development/testing)
  if (event.data && event.data.type === 'SIMULATE_PUSH') {
// Convert the simulated push data to match our PushPayload interface
    const data = event.data.data;
    const pushPayload: PushPayload = {
      type: 'announcement',
      title: data.title || 'Show Update',
      body: data.content || data.title,
      license_key: data.licenseKey,
      priority: data.priority || 'normal',
      url: '/announcements',
    };

    // Check for duplicates
    const messageId = generateMessageId(pushPayload);
    if (isDuplicateMessage(messageId)) {
return;
    }

    // Build notification options
    const isUrgent = pushPayload.priority === 'urgent';
    const isHigh = pushPayload.priority === 'high';

    const options: NotificationOptions & { actions?: NotificationAction[]; vibrate?: VibratePattern } = {
      body: pushPayload.body,
      icon: '/myK9Q-teal-192.png',
      badge: '/myK9Q-teal-192.png',
      vibrate: isUrgent ? [200, 100, 200, 100, 200] : [100],
      data: {
        url: pushPayload.url,
        type: pushPayload.type,
        license_key: pushPayload.license_key,
        priority: pushPayload.priority,
      },
      requireInteraction: isUrgent,
      tag: `announcement-${Date.now()}`,
      actions: [
        { action: 'view', title: 'View' },
        { action: 'dismiss', title: 'Dismiss' },
      ],
    };

    // Add priority indicators to title
    let title = pushPayload.title;
    if (data.showName && !title.includes(data.showName)) {
      title = `${data.showName}: ${title}`;
    }
    if (isUrgent) {
      title = `üö® ${title}`;
    } else if (isHigh) {
      title = `‚ö†Ô∏è ${title}`;
    }

    // Show the notification
    self.registration.showNotification(title, options)
      .then(() => {})
      .catch((error) => {
        logger.error('[Service Worker] ‚ùå Failed to show simulated notification:', error);
      });
  }
});

// =============================================
// BACKGROUND SYNC HANDLING
// =============================================
// Enables offline scores to sync even when app is closed
// Supported in Chrome/Edge, graceful degradation elsewhere
// Types defined in vite-env.d.ts

// Supabase config - injected at build time by Vite
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
const SUPABASE_ANON_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY as string;

// IndexedDB constants (must match DatabaseManager.ts)
const DB_NAME = 'myK9Q_Replication';
const DB_VERSION = 5;
const OFFLINE_QUEUE_STORE = 'offline_queue';

// QueuedScore interface (must match offlineQueueStore.ts)
interface QueuedScoreData {
  id: string;
  entryId: number;
  armband: number;
  classId: number;
  className: string;
  licenseKey: string;
  scoreData: {
    resultText: string;
    searchTime?: string;
    faultCount?: number;
    points?: number;
    nonQualifyingReason?: string;
    areas?: { [key: string]: string };
    healthCheckPassed?: boolean;
    mph?: number;
    score?: number;
    deductions?: number;
    correctCount?: number;
    incorrectCount?: number;
    finishCallErrors?: number;
    areaTimes?: string[];
    element?: string;
    level?: string;
  };
  timestamp: string;
  retryCount: number;
  maxRetries: number;
  status: 'pending' | 'syncing' | 'failed' | 'completed';
}

interface MutationEntry {
  id: string;
  type: string;
  data: QueuedScoreData;
  timestamp: number;
  retries: number;
  status: string;
}

/**
 * Open the replication database
 * Simplified version that only needs read/write access to offline_queue
 */
function openReplicationDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);

    request.onerror = () => {
      logger.error('[SW] Failed to open IndexedDB:', request.error);
      reject(request.error);
    };

    request.onsuccess = () => {
      resolve(request.result);
    };

    // If upgrade is needed, we're in trouble - shouldn't happen in SW
    request.onupgradeneeded = () => {
      logger.warn('[SW] IndexedDB upgrade needed - this should not happen');
    };
  });
}

/**
 * Build the score update payload for Supabase REST API
 */
function buildScoreUpdate(score: QueuedScoreData): Record<string, unknown> {
  const { scoreData } = score;

  // Map scoreData to database columns (matches scoreSubmission.ts logic)
  const update: Record<string, unknown> = {
    result_status: scoreData.resultText,
    is_scored: true,
    entry_status: 'completed',
    updated_at: new Date().toISOString(),
  };

  // Optional fields
  if (scoreData.searchTime) {
    // Convert MM:SS.mm to seconds
    const [minutes, rest] = scoreData.searchTime.split(':');
    const [seconds, ms] = (rest || '0').split('.');
    update.search_time_seconds =
      parseInt(minutes || '0') * 60 +
      parseInt(seconds || '0') +
      parseInt(ms || '0') / 100;
  }

  if (scoreData.faultCount !== undefined) {
    update.total_faults = scoreData.faultCount;
  }

  if (scoreData.points !== undefined) {
    update.points_earned = scoreData.points;
  }

  if (scoreData.nonQualifyingReason) {
    update.disqualification_reason = scoreData.nonQualifyingReason;
  }

  return update;
}

/**
 * Sync offline queue to Supabase
 * Called by browser when network is available and sync tag is registered
 */
async function syncOfflineQueue(): Promise<void> {
  logger.warn('[SW] üîÑ Background sync triggered');

  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    logger.error('[SW] Missing Supabase config - cannot sync');
    return;
  }

  let db: IDBDatabase;
  try {
    db = await openReplicationDB();
  } catch {
    logger.error('[SW] Failed to open database');
    return;
  }

  // Get all mutations from offline_queue store
  const mutations = await new Promise<MutationEntry[]>((resolve, reject) => {
    const tx = db.transaction(OFFLINE_QUEUE_STORE, 'readonly');
    const store = tx.objectStore(OFFLINE_QUEUE_STORE);
    const request = store.getAll();

    request.onsuccess = () => resolve(request.result as MutationEntry[]);
    request.onerror = () => reject(request.error);
  });

  // Filter for pending score submissions
  const pendingScores = mutations.filter(
    (m) => m.type === 'SUBMIT_SCORE' && m.status === 'pending'
  );

  if (pendingScores.length === 0) {
    logger.warn('[SW] No pending scores to sync');
    db.close();
    return;
  }

  logger.warn(`[SW] Syncing ${pendingScores.length} offline score(s)...`);

  let successCount = 0;

  for (const mutation of pendingScores) {
    const score = mutation.data;

    try {
      // Submit to Supabase REST API
      const response = await fetch(
        `${SUPABASE_URL}/rest/v1/entries?id=eq.${score.entryId}`,
        {
          method: 'PATCH',
          headers: {
            apikey: SUPABASE_ANON_KEY,
            Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
            'Content-Type': 'application/json',
            Prefer: 'return=minimal',
            'x-license-key': score.licenseKey,
          },
          body: JSON.stringify(buildScoreUpdate(score)),
        }
      );

      if (response.ok) {
        // Delete from queue
        await new Promise<void>((resolve, reject) => {
          const tx = db.transaction(OFFLINE_QUEUE_STORE, 'readwrite');
          const store = tx.objectStore(OFFLINE_QUEUE_STORE);
          const request = store.delete(mutation.id);

          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });

        successCount++;
        logger.warn(`[SW] ‚úÖ Synced score for entry ${score.entryId}`);
      } else {
        const errorText = await response.text();
        logger.error(`[SW] ‚ùå Failed to sync entry ${score.entryId}:`, errorText);
        // Don't delete - browser will retry
      }
    } catch (error) {
      logger.error(`[SW] ‚ùå Network error syncing entry ${score.entryId}:`, error);
      // Network error - browser will retry automatically
    }
  }

  db.close();

  // Notify all open clients that sync completed
  const clients = await self.clients.matchAll({ type: 'window' });
  clients.forEach((client) => {
    client.postMessage({
      type: 'BACKGROUND_SYNC_COMPLETE',
      syncedCount: successCount,
      totalCount: pendingScores.length,
    });
  });

  logger.warn(`[SW] üéâ Background sync complete: ${successCount}/${pendingScores.length}`);
}

/**
 * Handle background sync events
 */
self.addEventListener('sync', (event: SyncEvent) => {
  if (event.tag === 'offline-queue-sync') {
    event.waitUntil(syncOfflineQueue());
  }
});

