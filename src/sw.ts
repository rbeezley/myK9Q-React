/// <reference lib="webworker" />
import { clientsClaim } from 'workbox-core';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Define NotificationAction type (from Notifications API)
interface NotificationAction {
  action: string;
  title: string;
  icon?: string;
}

// Take control of all pages immediately
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Network-first strategy for Supabase API calls
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
  })
);

// =============================================
// PUSH NOTIFICATION HANDLING
// =============================================

interface PushPayload {
  type: 'announcement' | 'up_soon' | 'result' | 'class_started';
  title: string;
  body: string;
  license_key: string;
  priority?: 'normal' | 'high' | 'urgent'; // For announcements
  armband_number?: number;
  dog_name?: string;
  handler?: string;
  class_id?: string;
  entry_id?: string;
  url?: string;
  class_name?: string; // For class_started notifications
  class_status?: string; // For class_started notifications
  message_id?: string; // Optional unique message ID for duplicate detection
}

// =============================================
// DUPLICATE DETECTION
// =============================================

// In-memory cache for recent message IDs (lasts for service worker lifetime)
const recentMessageIds = new Set<string>();
const MESSAGE_ID_EXPIRY_MS = 15 * 60 * 1000; // 15 minutes

/**
 * Generate a message ID from payload if not provided
 * Used to detect duplicate notifications
 */
function generateMessageId(payload: PushPayload): string {
  if (payload.message_id) {
    return payload.message_id;
  }

  // Generate deterministic ID based on payload contents
  const parts = [
    payload.type,
    payload.license_key,
    payload.armband_number?.toString() || '',
    payload.entry_id || '',
    payload.title,
  ];

  return parts.join('-');
}

/**
 * Check if a message ID was recently seen
 * Returns true if this is a duplicate
 */
function isDuplicateMessage(messageId: string): boolean {
  if (recentMessageIds.has(messageId)) {
    console.log('[Service Worker] ðŸš« Duplicate message detected:', messageId);
    return true;
  }

  // Add to cache
  recentMessageIds.add(messageId);

  // Remove from cache after expiry time
  setTimeout(() => {
    recentMessageIds.delete(messageId);
  }, MESSAGE_ID_EXPIRY_MS);

  return false;
}

/**
 * Handle incoming push notifications
 * Shows notification even when app is closed
 */
self.addEventListener('push', (event: PushEvent) => {
  console.log('[Service Worker] Push event received:', event);

  if (!event.data) {
    console.warn('[Service Worker] Push event has no data');
    return;
  }

  try {
    const payload: PushPayload = event.data.json();
    console.log('[Service Worker] Push payload:', payload);

    // Check for duplicate messages
    const messageId = generateMessageId(payload);
    if (isDuplicateMessage(messageId)) {
      console.log('[Service Worker] Skipping duplicate notification');
      return;
    }

    // Build notification options
    // For announcements, use priority to determine requireInteraction
    const isUrgentAnnouncement = payload.type === 'announcement' && payload.priority === 'urgent';
    const isClassStarted = payload.type === 'class_started';

    const options: NotificationOptions & { actions?: NotificationAction[]; vibrate?: VibratePattern } = {
      body: payload.body,
      icon: '/icon-192x192.png',
      badge: '/icon-192x192.png',
      vibrate: isUrgentAnnouncement || isClassStarted ? [200, 100, 200] : [100], // More prominent vibration for urgent/class started
      data: {
        url: payload.url || '/',
        type: payload.type,
        license_key: payload.license_key,
        entry_id: payload.entry_id,
        armband_number: payload.armband_number,
        priority: payload.priority,
        class_id: payload.class_id,
        class_name: payload.class_name,
      },
      requireInteraction: payload.type === 'up_soon' || isUrgentAnnouncement || isClassStarted, // Up-soon, urgent announcements, and class started require interaction
      tag: payload.type === 'announcement' ? `announcement-${Date.now()}` :
           payload.type === 'class_started' ? `class-started-${payload.class_id}` :
           `up-soon-${payload.armband_number}`,
    };

    // Add action buttons based on notification type
    if (payload.type === 'up_soon') {
      options.actions = [
        { action: 'view', title: 'View Entry', icon: '/icon-192x192.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icon-192x192.png' },
      ];
    } else if (payload.type === 'announcement') {
      options.actions = [
        { action: 'view', title: 'View Details', icon: '/icon-192x192.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icon-192x192.png' },
      ];
    } else if (payload.type === 'class_started') {
      options.actions = [
        { action: 'view', title: 'View Class', icon: '/icon-192x192.png' },
        { action: 'dismiss', title: 'Dismiss', icon: '/icon-192x192.png' },
      ];
    }

    // Show notification with error handling
    const promiseChain = self.registration.showNotification(payload.title, options)
      .then(() => {
        console.log('[Service Worker] âœ… Notification displayed successfully');
      })
      .catch((error) => {
        console.error('[Service Worker] âŒ showNotification failed:', error);
      });

    event.waitUntil(promiseChain);
  } catch (error) {
    console.error('[Service Worker] Error handling push event:', error);
  }
});

/**
 * Handle notification clicks
 * Opens app and navigates to relevant page
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('[Service Worker] Notification click:', event.action, event.notification.data);

  // Close the notification
  event.notification.close();

  // Don't navigate if user clicked "dismiss"
  if (event.action === 'dismiss') {
    return;
  }

  // Determine URL to open
  const data = event.notification.data;
  let urlToOpen = '/';

  if (data.url) {
    urlToOpen = data.url;
  } else if (data.type === 'up_soon' && data.entry_id) {
    // Navigate to entry list (could be enhanced to open scoresheet)
    urlToOpen = `/entries`;
  } else if (data.type === 'announcement') {
    // Navigate to announcements page
    urlToOpen = `/announcements`;
  }

  // Full URL with origin
  const fullUrl = new URL(urlToOpen, self.location.origin).href;

  // Open or focus the app
  const promiseChain = self.clients
    .matchAll({ type: 'window', includeUncontrolled: true })
    .then((windowClients: readonly WindowClient[]) => {
      // Check if there's already a window open
      for (let i = 0; i < windowClients.length; i++) {
        const client = windowClients[i];
        if (client.url === fullUrl && 'focus' in client) {
          return client.focus();
        }
      }

      // No matching window found, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(fullUrl);
      }
    });

  event.waitUntil(promiseChain);
});

/**
 * Handle notification close events (optional analytics/logging)
 */
self.addEventListener('notificationclose', (event: NotificationEvent) => {
  console.log('[Service Worker] Notification closed:', event.notification.data);
  // Could send analytics event here if needed
});

/**
 * Handle service worker activation
 */
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activated');
  event.waitUntil(self.clients.claim());
});

/**
 * Handle service worker installation
 */
self.addEventListener('install', (_event) => {
  console.log('[Service Worker] Installed');
  // Skip waiting to activate immediately
  self.skipWaiting();
});

console.log('[Service Worker] myK9Q Service Worker loaded with push notification support');
