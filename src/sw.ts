/// <reference lib="webworker" />
// Service Worker Version: 2.4 - Green icon with solid background
import { clientsClaim } from 'workbox-core';
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Define NotificationAction type (from Notifications API)
interface NotificationAction {
  action: string;
  title: string;
  icon?: string;
}

// Take control of all pages immediately
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Network-first strategy for Supabase API calls
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-cache',
  })
);

// =============================================
// PUSH NOTIFICATION HANDLING
// =============================================

interface PushPayload {
  type: 'announcement' | 'up_soon' | 'result' | 'class_started';
  title: string;
  body: string;
  license_key: string;
  priority?: 'normal' | 'high' | 'urgent'; // For announcements
  armband_number?: number;
  dog_name?: string;
  handler?: string;
  class_id?: string;
  entry_id?: string;
  url?: string;
  class_name?: string; // For class_started notifications
  class_status?: string; // For class_started notifications
  message_id?: string; // Optional unique message ID for duplicate detection
}

// =============================================
// DUPLICATE DETECTION
// =============================================

// In-memory cache for recent message IDs (lasts for service worker lifetime)
const recentMessageIds = new Set<string>();
const MESSAGE_ID_EXPIRY_MS = 15 * 60 * 1000; // 15 minutes

/**
 * Generate a message ID from payload if not provided
 * Used to detect duplicate notifications
 */
function generateMessageId(payload: PushPayload): string {
  if (payload.message_id) {
    return payload.message_id;
  }

  // Generate deterministic ID based on payload contents
  const parts = [
    payload.type,
    payload.license_key,
    payload.armband_number?.toString() || '',
    payload.entry_id || '',
    payload.title,
  ];

  return parts.join('-');
}

/**
 * Check if a message ID was recently seen
 * Returns true if this is a duplicate
 */
function isDuplicateMessage(messageId: string): boolean {
  if (recentMessageIds.has(messageId)) {
return true;
  }

  // Add to cache
  recentMessageIds.add(messageId);

  // Remove from cache after expiry time
  setTimeout(() => {
    recentMessageIds.delete(messageId);
  }, MESSAGE_ID_EXPIRY_MS);

  return false;
}

/**
 * Handle incoming push notifications
 * Shows notification even when app is closed
 */
self.addEventListener('push', (event: PushEvent) => {
if (!event.data) {
    console.warn('[Service Worker] Push event has no data');
    return;
  }

  try {
    const payload: PushPayload = event.data.json();
// Check for duplicate messages
    const messageId = generateMessageId(payload);
    if (isDuplicateMessage(messageId)) {
return;
    }

    // Build notification options
    // For announcements, use priority to determine requireInteraction
    const isUrgentAnnouncement = payload.type === 'announcement' && payload.priority === 'urgent';
    const isClassStarted = payload.type === 'class_started';

    const options: NotificationOptions & { actions?: NotificationAction[]; vibrate?: VibratePattern } = {
      body: payload.body,
      icon: '/myK9Q-teal-192.png',
      badge: '/myK9Q-teal-192.png',
      vibrate: isUrgentAnnouncement || isClassStarted ? [200, 100, 200] : [100], // More prominent vibration for urgent/class started
      data: {
        url: payload.url || '/',
        type: payload.type,
        license_key: payload.license_key,
        entry_id: payload.entry_id,
        armband_number: payload.armband_number,
        priority: payload.priority,
        class_id: payload.class_id,
        class_name: payload.class_name,
      },
      requireInteraction: payload.type === 'up_soon' || isUrgentAnnouncement || isClassStarted, // Up-soon, urgent announcements, and class started require interaction
      tag: payload.type === 'announcement' ? `announcement-${Date.now()}` :
           payload.type === 'class_started' ? `class-started-${payload.class_id}` :
           `up-soon-${payload.armband_number}`,
    };

    // Add action buttons based on notification type (no icons - they're too small)
    if (payload.type === 'up_soon') {
      options.actions = [
        { action: 'view', title: 'View Entry' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    } else if (payload.type === 'announcement') {
      options.actions = [
        { action: 'view', title: 'View' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    } else if (payload.type === 'class_started') {
      options.actions = [
        { action: 'view', title: 'View Class' },
        { action: 'dismiss', title: 'Dismiss' },
      ];
    }

    // Show notification with error handling
    const promiseChain = self.registration.showNotification(payload.title, options)
      .then(() => {})
      .catch((error) => {
        console.error('[Service Worker] ‚ùå showNotification failed:', error);
      });

    event.waitUntil(promiseChain);
  } catch (error) {
    console.error('[Service Worker] Error handling push event:', error);
  }
});

/**
 * Handle notification clicks
 * Opens app and navigates to relevant page
 */
self.addEventListener('notificationclick', (event: NotificationEvent) => {
// Close the notification
  event.notification.close();

  // Don't navigate if user clicked "dismiss"
  if (event.action === 'dismiss') {
    return;
  }

  // Determine URL to open
  const data = event.notification.data;
  let urlToOpen = '/';

  if (data.url) {
    urlToOpen = data.url;
  } else if (data.type === 'up_soon' && data.entry_id) {
    // Navigate to entry list (could be enhanced to open scoresheet)
    urlToOpen = `/entries`;
  } else if (data.type === 'announcement') {
    // Navigate to announcements page
    urlToOpen = `/announcements`;
  }

  // Full URL with origin
  const fullUrl = new URL(urlToOpen, self.location.origin).href;

  // Open or focus the app
  const promiseChain = self.clients
    .matchAll({ type: 'window', includeUncontrolled: true })
    .then((windowClients: readonly WindowClient[]) => {
      // Check if there's already a window open
      for (let i = 0; i < windowClients.length; i++) {
        const client = windowClients[i];
        if (client.url === fullUrl && 'focus' in client) {
          return client.focus();
        }
      }

      // No matching window found, open a new one
      if (self.clients.openWindow) {
        return self.clients.openWindow(fullUrl);
      }
    });

  event.waitUntil(promiseChain);
});

/**
 * Handle notification close events (optional analytics/logging)
 */
self.addEventListener('notificationclose', (_event: NotificationEvent) => {
  // Could send analytics event here if needed
});

/**
 * Handle service worker activation
 */
self.addEventListener('activate', (event) => {
event.waitUntil(self.clients.claim());
});

/**
 * Handle service worker installation
 */
self.addEventListener('install', (_event) => {
// Skip waiting to activate immediately
  self.skipWaiting();
});

/**
 * Handle messages from the main thread
 * Used for simulating push notifications in development
 */
self.addEventListener('message', (event: ExtendableMessageEvent) => {
// Handle simulated push notifications (for development/testing)
  if (event.data && event.data.type === 'SIMULATE_PUSH') {
// Convert the simulated push data to match our PushPayload interface
    const data = event.data.data;
    const pushPayload: PushPayload = {
      type: 'announcement',
      title: data.title || 'Show Update',
      body: data.content || data.title,
      license_key: data.licenseKey,
      priority: data.priority || 'normal',
      url: '/announcements',
    };

    // Check for duplicates
    const messageId = generateMessageId(pushPayload);
    if (isDuplicateMessage(messageId)) {
return;
    }

    // Build notification options
    const isUrgent = pushPayload.priority === 'urgent';
    const isHigh = pushPayload.priority === 'high';

    const options: NotificationOptions & { actions?: NotificationAction[]; vibrate?: VibratePattern } = {
      body: pushPayload.body,
      icon: '/myK9Q-teal-192.png',
      badge: '/myK9Q-teal-192.png',
      vibrate: isUrgent ? [200, 100, 200, 100, 200] : [100],
      data: {
        url: pushPayload.url,
        type: pushPayload.type,
        license_key: pushPayload.license_key,
        priority: pushPayload.priority,
      },
      requireInteraction: isUrgent,
      tag: `announcement-${Date.now()}`,
      actions: [
        { action: 'view', title: 'View' },
        { action: 'dismiss', title: 'Dismiss' },
      ],
    };

    // Add priority indicators to title
    let title = pushPayload.title;
    if (data.showName && !title.includes(data.showName)) {
      title = `${data.showName}: ${title}`;
    }
    if (isUrgent) {
      title = `üö® ${title}`;
    } else if (isHigh) {
      title = `‚ö†Ô∏è ${title}`;
    }

    // Show the notification
    self.registration.showNotification(title, options)
      .then(() => {})
      .catch((error) => {
        console.error('[Service Worker] ‚ùå Failed to show simulated notification:', error);
      });
  }
});

