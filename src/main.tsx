import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { registerSW } from 'virtual:pwa-register'
import { serviceWorkerManager } from './utils/serviceWorkerUtils'
import { initializeReplication } from './services/replication/initReplication'
import { initSyncStatusListeners } from './stores/syncStatusStore'
import { logger } from './utils/logger'
import { UpdateToast } from './components/ui/UpdateToast'
import { buildTimestamp } from './config/appVersion'

// Global error handlers - catch unhandled async errors and uncaught exceptions
// These provide a safety net for errors that escape try/catch blocks
window.addEventListener('unhandledrejection', (event: PromiseRejectionEvent) => {
  logger.error('[Unhandled Promise Rejection]', event.reason)
  // Prevent default browser logging (we handle it ourselves)
  event.preventDefault()
})

window.addEventListener('error', (event: ErrorEvent) => {
  // Only log if it's not already handled by React's error boundary
  if (!event.defaultPrevented) {
    logger.error('[Uncaught Error]', event.error || event.message)
  }
})

// Build timestamp - auto-generated by Vite at build time (see vite.config.ts)
// This ensures every deployment gets a unique version for cache busting
const APP_VERSION = buildTimestamp;
// Track if user has been prompted about this update (persist across sessions)
const getLastPromptedVersion = () => localStorage.getItem('sw_prompted_version');
const setLastPromptedVersion = () => localStorage.setItem('sw_prompted_version', APP_VERSION);

/**
 * Check if user is currently on a scoresheet page.
 * We defer update prompts during active scoring to avoid interruptions.
 */
const isOnScoresheet = () => {
  const path = window.location.pathname;
  return path.includes('/score') || path.includes('/entry/');
};

/**
 * Show the PWA update toast.
 * Renders into a separate DOM root to keep it isolated from the main React app.
 */
const showUpdateToast = () => {
  const container = document.getElementById('update-toast-root');
  if (!container) {
    logger.error('[PWA] Update toast container not found');
    return;
  }

  const toastRoot = ReactDOM.createRoot(container);

  const handleUpdate = () => {
    toastRoot.unmount();
    updateSW(true);
  };

  const handleLater = () => {
    toastRoot.unmount();
  };

  toastRoot.render(
    <UpdateToast onUpdate={handleUpdate} onLater={handleLater} />
  );
};

const updateSW = registerSW({
  onNeedRefresh() {
    // In development, don't auto-prompt for refresh to avoid interrupting work
    if (import.meta.env.DEV) {
      return
    }

    // Only prompt once per app version (persists across sessions/refreshes)
    // This prevents repeated prompts during PTR or page navigation
    const lastPrompted = getLastPromptedVersion();
    if (lastPrompted === APP_VERSION) {
      return
    }

    setLastPromptedVersion();

    // Defer showing toast if user is on a scoresheet (don't interrupt scoring)
    if (isOnScoresheet()) {
      const checkInterval = setInterval(() => {
        if (!isOnScoresheet()) {
          clearInterval(checkInterval);
          showUpdateToast();
        }
      }, 2000);
    } else {
      showUpdateToast();
    }
  },
  onOfflineReady() {
    // Initialize service worker manager when offline-ready
    serviceWorkerManager.initialize().catch(console.error)
  },
  onRegisteredSW(swUrl, registration) {
    // Initialize service worker manager
    serviceWorkerManager.initialize().catch(console.error)

    // Periodically check for service worker updates (every 10 minutes)
    // This ensures users get prompted for updates even if they keep the app open
    if (registration && !import.meta.env.DEV) {
      const CHECK_INTERVAL = 10 * 60 * 1000; // 10 minutes

      setInterval(() => {
        // Only check if user is online and not actively scoring
        if (navigator.onLine && !isOnScoresheet()) {
          logger.log('üîÑ [PWA] Checking for service worker updates...');
          registration.update().catch((err: Error) => {
            logger.warn('‚ö†Ô∏è [PWA] Update check failed:', err.message);
          });
        }
      }, CHECK_INTERVAL);

      // Also check immediately after a brief delay (gives SW time to initialize)
      setTimeout(() => {
        if (navigator.onLine) {
          registration.update().catch((err: Error) => {
            logger.warn('‚ö†Ô∏è [PWA] Initial update check failed:', err.message);
          });
        }
      }, 5000);
    }
  }
})

// Initialize sync status listeners BEFORE replication starts
// This ensures we capture the initial sync success event
initSyncStatusListeners()

// Initialize replication immediately for faster startup
initializeReplication().catch(console.error)

// Debug window interface for development tools
interface DebugWindow extends Window {
  debugForceFullSync?: () => Promise<void>;
  debugInspectCache?: (tableName?: string) => Promise<unknown[] | undefined>;
}

// Expose debug functions (development only)
if (import.meta.env.DEV && typeof window !== 'undefined') {
  const debugWindow = window as DebugWindow;

  // Force full sync
  debugWindow.debugForceFullSync = async () => {
    const { triggerFullSync } = await import('./services/replication/initReplication')
    const auth = JSON.parse(localStorage.getItem('myK9Q_auth') || '{}') as { showContext?: { licenseKey?: string } }
    const licenseKey = auth.showContext?.licenseKey
    if (!licenseKey) {
      logger.error('‚ùå No license key found')
      return
    }
    await triggerFullSync(licenseKey)
  }

  // Inspect cache contents
  debugWindow.debugInspectCache = async (tableName = 'classes') => {
    const { getReplicationManager } = await import('./services/replication/initReplication')
    const manager = getReplicationManager()
    if (!manager) {
      logger.error('‚ùå ReplicationManager not initialized')
      return
    }
    const table = manager.getTable(tableName)
    if (!table) {
      logger.error(`‚ùå Table "${tableName}" not found`)
      return
    }
    const allRecords = await table.getAll()
    return allRecords
  }
}

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)